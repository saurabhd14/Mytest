
#ifndef __2WAYRANGING_H
#define __2WAYRANGING_H

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include "../utils/utils.h"
#include "../device/dw1000.h"

#define RESULT_STACK_MAX_SIZE    10
#define FILTER_SIZE              10
#define RANGING_CYCLE_TIMOUT     0.05//1.0
#define MAX_CONNECTIONS          3
#define CALBRATED_ANTENNA_OFFSET 1.064 /* In meter -> calbrated on 5 meters */



//Predefined delay for the critical answers in the ranging algorithm
//HAS TO BE BIGGER THAN THE PROCESSING TIME OF THE FRAME ON THE NODE
#define ANSWER_DELAY_US             20000 // 2500                                    //2500 works for 110kbps, 900 for 6.8Mbps
#define ANSWER_DELAY_TIMEUNITS      ANSWER_DELAY_US * US_TO_TIMEUNITS

class CTwoWayRanging
{

public:
	CTwoWayRanging(DW1000 *_dw, bool _anchor_mode);

	void RequestFilteredDistance(int destination);
	bool requestRangingAll(); /* Multi Anchor*/
	void RequestRanging(int destination);
	bool RequestCalibrationValue(int destination, double calibration_distance);
	void CallbackRX();
	void CallbackTX();

	bool anchor_mode;
	int address; // Identifies the nodes as source and destination in ranging frames

	float distances[MAX_CONNECTIONS+1]; // Array containing the finally calculated Distances to the anchors

	bool overflow;              // TRUE if counter overflows while ranging
	double result_stack[MAX_CONNECTIONS][RESULT_STACK_MAX_SIZE];
	int result_stack_size[MAX_CONNECTIONS];
	
	
	/* Calibration variables */
	bool calibration_mode;
	int ranging_count;
	double sum_ranges;

private:


	DW1000 *dw;
	STimer local_timer;

	void SendPingFrame(uint8_t destination);
	void SendAnswer(uint8_t destination, uint8_t type);
	void SendDelayedAnswer(uint8_t destination, uint8_t type, uint64_t rx_timestamp);
	void SendTransferFrame(uint8_t destination, uint64_t _t_reply1, uint64_t _t_round2);

	/**
	 * These two functions correct the timestamps if the counter had an overflow between measurements
	 */
	void CorrectReceiverTimestamps(int source);
	void CorrectSenderTimestamps(int source);

	enum FrameType{
		PING=1,
		ANCHOR_RESPONSE,
		BEACON_RESPONSE,
		TRANSFER_FRAME,
		DISTANCES_FRAME
	};

	struct __attribute__((packed, aligned(1))) RangingFrame
	{
		uint8_t source;
		uint8_t destination;
		uint8_t type;
	};

	struct __attribute__((packed, aligned(1))) ExtendedRangingFrame : RangingFrame
	{
		int64_t t_reply1;
		int64_t t_round2;
	};

	struct __attribute__((packed, aligned(1))) SmallMacEnvelop
	{
		uint16_t frame_control;
		uint8_t sequence_number;
		uint16_t dest_pan;
		uint16_t dest_address;
		uint16_t source_pan;
		uint16_t source_address;
		ExtendedRangingFrame payload; /* TODO: Need to improve this */
		/* FCS should be autogenerated by dw1000 */
	};



	SmallMacEnvelop mac_envelop;
	ExtendedRangingFrame ranging_frame; /* TODO: Diversify this part and structure it better */
	ExtendedRangingFrame transfer_frame;
	SmallMacEnvelop received_frame;
	uint64_t sender_timestamps[MAX_CONNECTIONS][3];
	uint64_t receiver_timestamps[MAX_CONNECTIONS][3];
	bool acknowledgement[MAX_CONNECTIONS+1];                   // flag to indicate if ranging has succeeded



};

#endif // __2WAYRANGING_H
